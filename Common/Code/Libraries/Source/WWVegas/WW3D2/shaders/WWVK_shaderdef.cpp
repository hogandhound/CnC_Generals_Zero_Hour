//THIS FILE WAS AUTO-GENERATED BY VKSHADERTOHEADER
#include "WWVK_shaderdef.h"
#include "VkRenderTarget.h"
#include <stdexcept>
#include "VkTexture.h"
static VkShaderModule createShaderModule(VkDevice device, const unsigned char* code, size_t codeSize) {
    VkShaderModuleCreateInfo createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    createInfo.codeSize = codeSize;
    createInfo.pCode = reinterpret_cast<const uint32_t*>(code);

    VkShaderModule shaderModule;
    if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
        throw std::runtime_error("failed to create shader module!");
    }

    return shaderModule;
}
void WWVK_CreateFVF_DPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzd_vert, sizeof(WWVK_fvf_xyzd_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_d_frag, sizeof(WWVK_fvf_d_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 4;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_FVF_D].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_D].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV_DropUVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_d_frag, sizeof(WWVK_fvf_d_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_ALWAYS;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV_DropUVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV_DropUVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV_NoDiffusePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_nodiffuse_frag, sizeof(WWVK_fvf_duv_nodiffuse_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_SRC_COLOR;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_ALWAYS;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV_NoDiffuseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV_NoDiffuseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV_GrayscalePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_grayscale_frag, sizeof(WWVK_fvf_duv_grayscale_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV_GrayscaleDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV_GrayscaleDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV_CAMUVT_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_camuvt_vert, sizeof(WWVK_fvf_xyzduv_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv2_frag, sizeof(WWVK_fvf_duv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV_CAMUVT_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV_CAMUVT_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV_DepthBias_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    rasterizer.depthBiasEnable = VK_TRUE;
    rasterizer.depthBiasClamp = -1.0;
    rasterizer.depthBiasConstantFactor = -0.0005f;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV_DepthBias_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV_DepthBias_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV_CAMUVT_DepthBias_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_camuvt_vert, sizeof(WWVK_fvf_xyzduv_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv2_frag, sizeof(WWVK_fvf_duv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    rasterizer.depthBiasEnable = VK_TRUE;
    rasterizer.depthBiasClamp = -1.0;
    rasterizer.depthBiasConstantFactor = -0.0005f;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV_CAMUVT_DepthBias_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV_CAMUVT_DepthBias_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv2_frag, sizeof(WWVK_fvf_duv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV2_DropUVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV2_DropUVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV2_DropUVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV2_DropUV_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV2_DropUV_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV2_DropUV_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV2_DropUV_ARefPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_aref_frag, sizeof(WWVK_fvf_duv_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV2_DropUV_ARefDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV2_DropUV_ARefDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV2_TerrainPassPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_camuvt_vert, sizeof(WWVK_fvf_xyzduv2_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv2_camuvt_drop2_frag, sizeof(WWVK_fvf_duv2_camuvt_drop2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_SRC_COLOR;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV2_TerrainPassDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV2_TerrainPassDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_DUV2_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv2_frag, sizeof(WWVK_fvf_duv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_DUV2_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_DUV2_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_frag, sizeof(WWVK_fvf_nuv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_frag, sizeof(WWVK_fvf_nuv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_ARefPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_aref_frag, sizeof(WWVK_fvf_nuv_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_ARefDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_ARefDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_NoDiffusePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_frag, sizeof(WWVK_fvf_nuv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_NoDiffuseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_NoDiffuseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_NOL_NoDiffusePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_nol_frag, sizeof(WWVK_fvf_nuv_nol_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_NOL_NoDiffuseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_NOL_NoDiffuseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_CAMUVT_DROPUV_NOL_NoDiffusePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_camuvt_vert, sizeof(WWVK_fvf_xyznuv1_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_nol_camuvt_drop1_frag, sizeof(WWVK_fvf_nuv_nol_camuvt_drop1_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_NoTexPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_n_frag, sizeof(WWVK_fvf_n_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_NoTexDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 2;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 3;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UUUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_NoTexDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 2;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 3;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_UVTPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_uvt_vert, sizeof(WWVK_fvf_xyznuv1_uvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_frag, sizeof(WWVK_fvf_nuv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_UVTDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_UVTDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_DROPUV_REFLUVTPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_refluvt_vert, sizeof(WWVK_fvf_xyznuv1_refluvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_dropuv_refluvt_frag, sizeof(WWVK_fvf_nuv_dropuv_refluvt_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_DROPUV_REFLUVTDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_DROPUV_REFLUVTDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_DROPUV_REFLUVT_ARefPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_refluvt_vert, sizeof(WWVK_fvf_xyznuv1_refluvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_dropuv_refluvt_aref_frag, sizeof(WWVK_fvf_nuv_dropuv_refluvt_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_DROPUV_REFLUVT_ARefDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 10;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_DROPUV_REFLUVT_ARefDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock, VK::Buffer ubo_AlphaRef) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    VkDescriptorBufferInfo bufferInfo_AlphaRef = {};
    bufferInfo_AlphaRef.buffer = ubo_AlphaRef.buffer;
    bufferInfo_AlphaRef.offset = 0;
    bufferInfo_AlphaRef.range = sizeof(AlphaRef);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 10;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_AlphaRef;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_ARef_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_aref_frag, sizeof(WWVK_fvf_nuv_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_ARef_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_ARef_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_2TexPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_2tex_frag, sizeof(WWVK_fvf_nuv_2tex_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_2TexDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 6;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_2TexDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 6;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_2Tex_NoDiffusePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_2tex_frag, sizeof(WWVK_fvf_nuv_2tex_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_2Tex_NoDiffuseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 6;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_2Tex_NoDiffuseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 6;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_UVT_UVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_uvt_uv_vert, sizeof(WWVK_fvf_xyznuv1_uvt_uv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv2_frag, sizeof(WWVK_fvf_nuv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_UVT_UVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 6;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_UVT_UVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 6;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_REFLUVT_UVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_refluvt_uv_vert, sizeof(WWVK_fvf_xyznuv1_refluvt_uv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv2_frag, sizeof(WWVK_fvf_nuv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_REFLUVT_UVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 6;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_REFLUVT_UVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 6;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_UVT12Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_uvt12_vert, sizeof(WWVK_fvf_xyznuv1_uvt12_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv2_frag, sizeof(WWVK_fvf_nuv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_UVT12DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 6;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 4;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 2;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[6].binding = 3;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_UVT12DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 6;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 4;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_UVT2;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 2;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 3;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NUV_2Tex_ARefPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznuv1_vert, sizeof(WWVK_fvf_xyznuv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nuv_2tex_aref_frag, sizeof(WWVK_fvf_nuv_2tex_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NUV_2Tex_ARefDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NUV_2Tex_ARefDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzn_vert, sizeof(WWVK_fvf_xyzn_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_n_frag, sizeof(WWVK_fvf_n_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 2;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 3;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UUUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_N].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_N].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 2;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 3;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_N_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzn_vert, sizeof(WWVK_fvf_xyzn_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_n_frag, sizeof(WWVK_fvf_n_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_N_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 2;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 3;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UUUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_N_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 2;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 3;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_N_NOLPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzn_vert, sizeof(WWVK_fvf_xyzn_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_DummyFrag_frag, sizeof(WWVK_DummyFrag_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_N_NOLDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_N_NOLDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_N_NOL_CAMUVTPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzn_camuvt_vert, sizeof(WWVK_fvf_xyzn_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_n_nol_camuvt_drop1_frag, sizeof(WWVK_fvf_n_nol_camuvt_drop1_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_N_NOL_CAMUVTDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_N_NOL_CAMUVTDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_vert, sizeof(WWVK_fvf_xyznduv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_frag, sizeof(WWVK_fvf_nduv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_NOLPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_vert, sizeof(WWVK_fvf_xyznduv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_noL_frag, sizeof(WWVK_fvf_nduv_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_NOLDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_NOLDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_AREFPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_vert, sizeof(WWVK_fvf_xyznduv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_aref_frag, sizeof(WWVK_fvf_nduv_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_AREFDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_AREFDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_AREF_StripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_vert, sizeof(WWVK_fvf_xyznduv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_aref_frag, sizeof(WWVK_fvf_nduv_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_AREF_StripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_AREF_StripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_REFLUVT_DROPUVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_refluvt_dropuv_vert, sizeof(WWVK_fvf_xyznduv1_refluvt_dropuv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_frag, sizeof(WWVK_fvf_nduv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 3;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 7;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_REFLUVT_DROPUVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_REFLUVT_DROPUVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_CAMUVT_NOLPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_camuvt_vert, sizeof(WWVK_fvf_xyznduv1_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noL_frag, sizeof(WWVK_fvf_nduv2_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_CAMUVT_NOLDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_CAMUVT_NOLDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_CAMUVT_NOL_AREFPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_camuvt_2_vert, sizeof(WWVK_fvf_xyznduv1_camuvt_2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noL_aref_frag, sizeof(WWVK_fvf_nduv2_noL_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_CAMUVT_NOL_AREFDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_CAMUVT_NOL_AREFDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOLPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_camuvt_vert, sizeof(WWVK_fvf_xyznduv1_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_dropuv_camuvt_nodiffuse_noL_frag, sizeof(WWVK_fvf_nduv_dropuv_camuvt_nodiffuse_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOLDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOLDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffusePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_camuvt_vert, sizeof(WWVK_fvf_xyznduv1_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_dropuv_camuvt_nodiffuse_frag, sizeof(WWVK_fvf_nduv_dropuv_camuvt_nodiffuse_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffuseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_DropUV_CAMUVT_NoDiffuseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_NoDiffusePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_vert, sizeof(WWVK_fvf_xyznduv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_nodiffuse_frag, sizeof(WWVK_fvf_nduv_nodiffuse_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_NoDiffuseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_NoDiffuseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_UVT_NOLPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_uvt_vert, sizeof(WWVK_fvf_xyznduv1_uvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_noL_frag, sizeof(WWVK_fvf_nduv_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUvt);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_UVT_NOLDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_UVT_NOLDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_UVT2_UVT_PLUS_UVTRGBPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_uvt2_vert, sizeof(WWVK_fvf_xyznduv1_uvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_uv_plus_uv_rgb_frag, sizeof(WWVK_fvf_nduv_uv_plus_uv_rgb_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_UVT2_UVT_PLUS_UVTRGBDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 10;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_UVT2_UVT_PLUS_UVTRGBDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 10;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_UVT2;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV_UV_PLUS_UVRGBPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv1_vert, sizeof(WWVK_fvf_xyznduv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_uv_plus_uv_rgb_frag, sizeof(WWVK_fvf_nduv_uv_plus_uv_rgb_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV_UV_PLUS_UVRGBDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV_UV_PLUS_UVRGBDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_frag, sizeof(WWVK_fvf_nduv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_UVT2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_uvt2_vert, sizeof(WWVK_fvf_xyznduv2_uvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_frag, sizeof(WWVK_fvf_nduv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_UVT2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_UVT2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGBPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_uvt2_dropuv_vert, sizeof(WWVK_fvf_xyznduv2_uvt2_dropuv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_uv_plus_uv_rgb_frag, sizeof(WWVK_fvf_nduv_uv_plus_uv_rgb_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 4;
        attributeDescriptions[4].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[4].offset = sizeof(float) * 9;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGBDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 10;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGBDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 10;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_UVT2;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DROPUV_UV_PLUS_UVRGBPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_uvt2_dropuv_vert, sizeof(WWVK_fvf_xyznduv2_uvt2_dropuv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_uv_plus_uv_rgb_frag, sizeof(WWVK_fvf_nduv_uv_plus_uv_rgb_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 4;
        attributeDescriptions[4].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[4].offset = sizeof(float) * 9;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DROPUV_UV_PLUS_UVRGBDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 10;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DROPUV_UV_PLUS_UVRGBDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 10;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_UVT2;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_UVT2_NoAlpha2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_uvt2_vert, sizeof(WWVK_fvf_xyznduv2_uvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noalpha2_frag, sizeof(WWVK_fvf_nduv2_noalpha2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_UVT2_NoAlpha2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_UVT2_NoAlpha2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NoAlpha2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noalpha2_frag, sizeof(WWVK_fvf_nduv2_noalpha2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NoAlpha2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NoAlpha2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DropUVPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_dropuv_frag, sizeof(WWVK_fvf_nduv2_dropuv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DropUVDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DropUVDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DropUV_RGB1_A2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_dropuv_rgb1_a2_frag, sizeof(WWVK_fvf_nduv2_dropuv_rgb1_a2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DropUV_RGB1_A2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DropUV_RGB1_A2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_UVT1_UV1Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_uvt1_uv1_vert, sizeof(WWVK_fvf_xyznduv2_uvt1_uv1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_frag, sizeof(WWVK_fvf_nduv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 4;
        attributeDescriptions[4].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[4].offset = sizeof(float) * 9;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_UVT1_UV1DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_UVT1_UV1DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DropUV_ARefPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_dropuv_aref_frag, sizeof(WWVK_fvf_nduv2_dropuv_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DropUV_ARefDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[5].binding = 3;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DropUV_ARefDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 3;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DropTex_ARefPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_aref_frag, sizeof(WWVK_fvf_nduv_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DropTex_ARefDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DropTex_ARefDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DropTex_UV2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_dropTex_uv2_frag, sizeof(WWVK_fvf_nduv2_dropTex_uv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DropTex_UV2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DropTex_UV2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DropTexPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_frag, sizeof(WWVK_fvf_nduv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DropTexDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DropTexDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_UVT1_DropTexPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_uvt1_vert, sizeof(WWVK_fvf_xyznduv2_uvt1_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_frag, sizeof(WWVK_fvf_nduv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_UVT1_DropTexDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_UVT1_DropTexDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NOLPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noL_frag, sizeof(WWVK_fvf_nduv2_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NOLDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NOLDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NOL_OnlyTex1Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noL_onlytex1_frag, sizeof(WWVK_fvf_nduv2_noL_onlytex1_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NOL_OnlyTex1DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NOL_OnlyTex1DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_OnlyTex2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_onlytex2_frag, sizeof(WWVK_fvf_nduv2_onlytex2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_OnlyTex2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 3;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_OnlyTex2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 3;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_CAMUVT_NOL_OnlyTex1Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_camuvt_vert, sizeof(WWVK_fvf_xyznduv2_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_camuvt_noL_onlytex1_frag, sizeof(WWVK_fvf_nduv2_camuvt_noL_onlytex1_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_CAMUVT_NOL_OnlyTex1DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_CAMUVT_NOL_OnlyTex1DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NOL_DROPTEXPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_noL_frag, sizeof(WWVK_fvf_nduv_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NOL_DROPTEXDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NOL_DROPTEXDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NOL_DROPTEX2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nd_noL_frag, sizeof(WWVK_fvf_nd_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NOL_DROPTEX2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NOL_DROPTEX2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NOL_DROPTEX_NoTexAlphaPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_noL_notexalpha_frag, sizeof(WWVK_fvf_nduv_noL_notexalpha_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NOL_DROPTEX_NoTexAlphaDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NOL_DROPTEX_NoTexAlphaDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_DROPTEX2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nd_frag, sizeof(WWVK_fvf_nd_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_DROPTEX2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 2;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 3;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UUUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_DROPTEX2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_LightCollectionBlock, VK::Buffer ubo_MaterialBlock) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UUUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_LightCollectionBlock = {};
    bufferInfo_LightCollectionBlock.buffer = ubo_LightCollectionBlock.buffer;
    bufferInfo_LightCollectionBlock.offset = 0;
    bufferInfo_LightCollectionBlock.range = sizeof(LightCollectionBlock);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 2;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_LightCollectionBlock;
    VkDescriptorBufferInfo bufferInfo_MaterialBlock = {};
    bufferInfo_MaterialBlock.buffer = ubo_MaterialBlock.buffer;
    bufferInfo_MaterialBlock.offset = 0;
    bufferInfo_MaterialBlock.range = sizeof(MaterialBlock);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 3;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_MaterialBlock;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NOL_AREFPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noL_aref_frag, sizeof(WWVK_fvf_nduv2_noL_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NOL_AREFDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NOL_AREFDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFVF_NDUV2_NOL_AREF_DROPTEXPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_vert, sizeof(WWVK_fvf_xyznduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv_noL_aref_frag, sizeof(WWVK_fvf_nduv_noL_aref_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(AlphaRef);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFVF_NDUV2_NOL_AREF_DROPTEXDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFVF_NDUV2_NOL_AREF_DROPTEXDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateHaloPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateHaloDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateHaloDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_Halo].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Halo].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateDazzlePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_ALWAYS;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateDazzleDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateDazzleDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_Dazzle].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Dazzle].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateSnowPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_snow_vert, sizeof(WWVK_snow_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_snow_frag, sizeof(WWVK_snow_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 3;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[1] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 1;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateSnowDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateSnowDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_Snow].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Snow].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFTerrainPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_camuv_vert, sizeof(WWVK_fvf_xyzduv_camuv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fterrain_frag, sizeof(WWVK_fterrain_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFTerrainDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFTerrainDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex0, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_FTerrain].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FTerrain].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex0;
    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFTerrainNoisePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_camuv_vert, sizeof(WWVK_fvf_xyzduv_camuv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fterrainnoise_frag, sizeof(WWVK_fterrainnoise_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFTerrainNoiseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 0;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 1;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFTerrainNoiseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex0, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTUU, pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex0;
    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 0;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 1;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateFTerrainNoise2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_camuv_vert, sizeof(WWVK_fvf_xyzduv_camuv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fterrainnoise2_frag, sizeof(WWVK_fterrainnoise2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateFTerrainNoise2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateFTerrainNoise2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex0, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUU, pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex0;
    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex3;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateRoadPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv_frag, sizeof(WWVK_fvf_duv_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateRoadDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateRoadDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_Road].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Road].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateRoadNoisePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_camuvt_vert, sizeof(WWVK_fvf_xyzduv_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv2_frag, sizeof(WWVK_fvf_duv2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrixUVT);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateRoadNoiseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateRoadNoiseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_RoadNoise].subIndex, &pipeline.pipelines[PIPELINE_WWVK_RoadNoise].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateRoadNoise12Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_camuvt2_vert, sizeof(WWVK_fvf_xyzduv_camuvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_duv3_frag, sizeof(WWVK_fvf_duv3_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateRoadNoise12DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 0;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 1;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 2;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTUUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateRoadNoise12DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex0, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTUUU, pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].subIndex, &pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex0;
    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 0;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 1;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 2;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateMonochromePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_monochrome_frag, sizeof(WWVK_monochrome_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(Monochrome);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateMonochromeDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[3] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 3;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUU, bindings, 3);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateMonochromeDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUU, pipeline.pipelines[PIPELINE_WWVK_Monochrome].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Monochrome].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[3] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 3, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateMotionBlurPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv_vert, sizeof(WWVK_fvf_xyzduv_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_motionblur_frag, sizeof(WWVK_motionblur_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange[2];
    pushConstantRange[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange[0].size = sizeof(WorldMatrix);
    pushConstantRange[0].offset = 0;

    pushConstantRange[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange[1].size = sizeof(BumpEnv);
    pushConstantRange[1].offset = sizeof(WorldMatrix);

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 2;
    pipelineLayoutInfo.pPushConstantRanges = pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateMotionBlurDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 7;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 6;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateMotionBlurDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex0, VK::Texture* texture_tex1, VK::Texture* texture_tex3, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUU, pipeline.pipelines[PIPELINE_WWVK_MotionBlur].subIndex, &pipeline.pipelines[PIPELINE_WWVK_MotionBlur].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex0;
    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 7;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 6;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateBumpDiffPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_shd8bumpdiff_vert, sizeof(WWVK_shd8bumpdiff_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_shd8bumpdiff_frag, sizeof(WWVK_shd8bumpdiff_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 21;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[7] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 3;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 4;
        attributeDescriptions[4].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[4].offset = sizeof(float) * 12;
    }
    {
        attributeDescriptions[5].binding = 0;
        attributeDescriptions[5].location = 5;
        attributeDescriptions[5].format = VK_FORMAT_R32G32B32A32_SFLOAT;
        attributeDescriptions[5].offset = sizeof(float) * 15;
    }
    {
        attributeDescriptions[6].binding = 0;
        attributeDescriptions[6].location = 6;
        attributeDescriptions[6].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[6].offset = sizeof(float) * 19;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 7;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateBumpDiffDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateBumpDiffDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_texNorm, VK::Texture* texture_texDecal, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_SSBumpDiff) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUU, pipeline.pipelines[PIPELINE_WWVK_BumpDiff].subIndex, &pipeline.pipelines[PIPELINE_WWVK_BumpDiff].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_texNorm = {};
    imageInfo_texNorm.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_texNorm.imageView = texture_texNorm->imageView;
    imageInfo_texNorm.sampler = texture_texNorm->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_texNorm;
    VkDescriptorImageInfo imageInfo_texDecal = {};
    imageInfo_texDecal.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_texDecal.imageView = texture_texDecal->imageView;
    imageInfo_texDecal.sampler = texture_texDecal->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_texDecal;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_SSBumpDiff = {};
    bufferInfo_SSBumpDiff.buffer = ubo_SSBumpDiff.buffer;
    bufferInfo_SSBumpDiff.offset = 0;
    bufferInfo_SSBumpDiff.range = sizeof(SSBumpDiff);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_SSBumpDiff;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateBumpSpecPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_shd8bumpspec_vert, sizeof(WWVK_shd8bumpspec_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_shd8bumpspec_frag, sizeof(WWVK_shd8bumpspec_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 21;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[7] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 3;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 4;
        attributeDescriptions[4].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[4].offset = sizeof(float) * 12;
    }
    {
        attributeDescriptions[5].binding = 0;
        attributeDescriptions[5].location = 5;
        attributeDescriptions[5].format = VK_FORMAT_R32G32B32A32_SFLOAT;
        attributeDescriptions[5].offset = sizeof(float) * 15;
    }
    {
        attributeDescriptions[6].binding = 0;
        attributeDescriptions[6].location = 6;
        attributeDescriptions[6].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[6].offset = sizeof(float) * 19;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 7;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateBumpSpecDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateBumpSpecDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_texNorm, VK::Texture* texture_texDecal, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_SSBumpSpec) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUU, pipeline.pipelines[PIPELINE_WWVK_BumpSpec].subIndex, &pipeline.pipelines[PIPELINE_WWVK_BumpSpec].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_texNorm = {};
    imageInfo_texNorm.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_texNorm.imageView = texture_texNorm->imageView;
    imageInfo_texNorm.sampler = texture_texNorm->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_texNorm;
    VkDescriptorImageInfo imageInfo_texDecal = {};
    imageInfo_texDecal.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_texDecal.imageView = texture_texDecal->imageView;
    imageInfo_texDecal.sampler = texture_texDecal->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_texDecal;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_SSBumpSpec = {};
    bufferInfo_SSBumpSpec.buffer = ubo_SSBumpSpec.buffer;
    bufferInfo_SSBumpSpec.offset = 0;
    bufferInfo_SSBumpSpec.range = sizeof(SSBumpSpec);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_SSBumpSpec;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateSSBumpDiffPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_shd8ssbumpdiff_vert, sizeof(WWVK_shd8ssbumpdiff_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_shd8ssbumpdiff_frag, sizeof(WWVK_shd8ssbumpdiff_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 19;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[6] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 3;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 4;
        attributeDescriptions[4].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[4].offset = sizeof(float) * 12;
    }
    {
        attributeDescriptions[5].binding = 0;
        attributeDescriptions[5].location = 5;
        attributeDescriptions[5].format = VK_FORMAT_R32G32B32A32_SFLOAT;
        attributeDescriptions[5].offset = sizeof(float) * 15;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 6;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateSSBumpDiffDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 0;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[2].binding = 1;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 2;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TUUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateSSBumpDiffDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_texNorm, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_SSBumpDiff) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TUUU, pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].subIndex, &pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_texNorm = {};
    imageInfo_texNorm.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_texNorm.imageView = texture_texNorm->imageView;
    imageInfo_texNorm.sampler = texture_texNorm->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_texNorm;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 0;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 1;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_SSBumpDiff = {};
    bufferInfo_SSBumpDiff.buffer = ubo_SSBumpDiff.buffer;
    bufferInfo_SSBumpDiff.offset = 0;
    bufferInfo_SSBumpDiff.range = sizeof(SSBumpDiff);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 2;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_SSBumpDiff;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateSSBumpSpecPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_shd8ssbumpspec_vert, sizeof(WWVK_shd8ssbumpspec_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_shd8ssbumpspec_frag, sizeof(WWVK_shd8ssbumpspec_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 21;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[7] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 3;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 4;
        attributeDescriptions[4].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[4].offset = sizeof(float) * 12;
    }
    {
        attributeDescriptions[5].binding = 0;
        attributeDescriptions[5].location = 5;
        attributeDescriptions[5].format = VK_FORMAT_R32G32B32A32_SFLOAT;
        attributeDescriptions[5].offset = sizeof(float) * 15;
    }
    {
        attributeDescriptions[6].binding = 0;
        attributeDescriptions[6].location = 6;
        attributeDescriptions[6].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[6].offset = sizeof(float) * 19;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 7;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateSSBumpSpecDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 2;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateSSBumpSpecDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_texNorm, VK::Texture* texture_texDecal, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_SSBumpSpec) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUU, pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].subIndex, &pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_texNorm = {};
    imageInfo_texNorm.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_texNorm.imageView = texture_texNorm->imageView;
    imageInfo_texNorm.sampler = texture_texNorm->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_texNorm;
    VkDescriptorImageInfo imageInfo_texDecal = {};
    imageInfo_texDecal.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_texDecal.imageView = texture_texDecal->imageView;
    imageInfo_texDecal.sampler = texture_texDecal->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_texDecal;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_SSBumpSpec = {};
    bufferInfo_SSBumpSpec.buffer = ubo_SSBumpSpec.buffer;
    bufferInfo_SSBumpSpec.offset = 0;
    bufferInfo_SSBumpSpec.range = sizeof(SSBumpSpec);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 2;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_SSBumpSpec;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateTerrainPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_terrain_frag, sizeof(WWVK_terrain_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateTerrainDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 4;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateTerrainDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex0, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_Terrain].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Terrain].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 4;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex0;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateTerrainNoisePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_terrainnoise_frag, sizeof(WWVK_terrainnoise_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateTerrainNoiseDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 4;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 0;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 1;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateTerrainNoiseDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex0, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTUU, pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].subIndex, &pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 4;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex0;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 0;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 1;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateTerrainNoise2Pipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_vert, sizeof(WWVK_fvf_xyzduv2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_terrainnoise2_frag, sizeof(WWVK_terrainnoise2_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateTerrainNoise2DescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[6] = {};
    {
        bindings[0].binding = 5;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 4;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 6;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUU, bindings, 6);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateTerrainNoise2DescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex0, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUU, pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].subIndex, &pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[6] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 5;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex0 = {};
    imageInfo_tex0.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex0.imageView = texture_tex0->imageView;
    imageInfo_tex0.sampler = texture_tex0->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 4;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex0;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex3;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 6, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateTreesPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_Trees_vert, sizeof(WWVK_Trees_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_nduv2_noL_frag, sizeof(WWVK_fvf_nduv2_noL_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 9;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 2;
        attributeDescriptions[3].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[3].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateTreesDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[5] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[4].binding = 10;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 5;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUUU, bindings, 5);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateTreesDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_Trees) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUUU, pipeline.pipelines[PIPELINE_WWVK_Trees].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Trees].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[5] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_Trees = {};
    bufferInfo_Trees.buffer = ubo_Trees.buffer;
    bufferInfo_Trees.offset = 0;
    bufferInfo_Trees.range = sizeof(Trees);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 10;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Trees;
    vkUpdateDescriptorSets(target->device, 5, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateWavePipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_wave_vert, sizeof(WWVK_wave_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_wave_frag, sizeof(WWVK_wave_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 6;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[3] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 2;
        attributeDescriptions[1].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[1].offset = sizeof(float) * 5;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 0;
        attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT|VK_SHADER_STAGE_FRAGMENT_BIT;
    pushConstantRange.size = sizeof(Wave);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateWaveDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[4] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 0;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[3].binding = 1;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 4;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTUU, bindings, 4);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateWaveDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex, VK::Texture* texture_tex1, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTUU, pipeline.pipelines[PIPELINE_WWVK_Wave].subIndex, &pipeline.pipelines[PIPELINE_WWVK_Wave].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[4] = {};

    VkDescriptorImageInfo imageInfo_tex = {};
    imageInfo_tex.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex.imageView = texture_tex->imageView;
    imageInfo_tex.sampler = texture_tex->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex;
    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex1;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 0;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 1;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 4, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateRiverWaterPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_camuvt_vert, sizeof(WWVK_fvf_xyznduv2_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_RiverWater_frag, sizeof(WWVK_RiverWater_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateRiverWaterDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[6].binding = 2;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateRiverWaterDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Texture* texture_tex4, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUUU, pipeline.pipelines[PIPELINE_WWVK_RiverWater].subIndex, &pipeline.pipelines[PIPELINE_WWVK_RiverWater].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex4 = {};
    imageInfo_tex4.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex4.imageView = texture_tex4->imageView;
    imageInfo_tex4.sampler = texture_tex4->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex4;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 2;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateRiverWaterAddPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_camuvt_vert, sizeof(WWVK_fvf_xyznduv2_camuvt_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_RiverWater_frag, sizeof(WWVK_RiverWater_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_TRUE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateRiverWaterAddDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[6].binding = 2;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateRiverWaterAddDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Texture* texture_tex4, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUUU, pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].subIndex, &pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex4 = {};
    imageInfo_tex4.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex4.imageView = texture_tex4->imageView;
    imageInfo_tex4.sampler = texture_tex4->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex4;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 2;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateRiverWaterShroudPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyznduv2_camuvt2_vert, sizeof(WWVK_fvf_xyznduv2_camuvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_RiverWaterShroud_frag, sizeof(WWVK_RiverWaterShroud_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 11;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[5] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 3;
        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = sizeof(float) * 7;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 4;
        attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 9;
    }
    {
        attributeDescriptions[4].binding = 0;
        attributeDescriptions[4].location = 2;
        attributeDescriptions[4].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[4].offset = sizeof(float) * 6;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 5;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateRiverWaterShroudDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[6].binding = 2;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateRiverWaterShroudDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Texture* texture_tex4, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUUU, pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].subIndex, &pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex4 = {};
    imageInfo_tex4.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex4.imageView = texture_tex4->imageView;
    imageInfo_tex4.sampler = texture_tex4->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex4;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 2;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateWaterTrapezoidPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_camuvt2_vert, sizeof(WWVK_fvf_xyzduv2_camuvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_WaterTrapezoid_frag, sizeof(WWVK_WaterTrapezoid_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateWaterTrapezoidDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[6].binding = 2;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateWaterTrapezoidDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Texture* texture_tex4, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUUU, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].subIndex, &pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex4 = {};
    imageInfo_tex4.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex4.imageView = texture_tex4->imageView;
    imageInfo_tex4.sampler = texture_tex4->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex4;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 2;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateWaterTrapezoid_DstAlphaPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_camuvt2_vert, sizeof(WWVK_fvf_xyzduv2_camuvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_WaterTrapezoid_frag, sizeof(WWVK_WaterTrapezoid_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateWaterTrapezoid_DstAlphaDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[6].binding = 2;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateWaterTrapezoid_DstAlphaDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Texture* texture_tex4, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUUU, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].subIndex, &pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex4 = {};
    imageInfo_tex4.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex4.imageView = texture_tex4->imageView;
    imageInfo_tex4.sampler = texture_tex4->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex4;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 2;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateWaterTrapezoid_DstAlphaInvDestPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_camuvt2_vert, sizeof(WWVK_fvf_xyzduv2_camuvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_WaterTrapezoid_frag, sizeof(WWVK_WaterTrapezoid_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_DST_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateWaterTrapezoid_DstAlphaInvDestDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[6].binding = 2;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateWaterTrapezoid_DstAlphaInvDestDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Texture* texture_tex4, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUUU, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].subIndex, &pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex4 = {};
    imageInfo_tex4.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex4.imageView = texture_tex4->imageView;
    imageInfo_tex4.sampler = texture_tex4->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex4;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 2;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateWaterTrapezoidStripPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzduv2_camuvt2_vert, sizeof(WWVK_fvf_xyzduv2_camuvt2_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_WaterTrapezoid_frag, sizeof(WWVK_WaterTrapezoid_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 8;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[4] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 2;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 4;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 3;
        attributeDescriptions[1].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 6;
    }
    {
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 1;
        attributeDescriptions[2].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[2].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 0;
        attributeDescriptions[3].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 4;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateWaterTrapezoidStripDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[7] = {};
    {
        bindings[0].binding = 4;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[1].binding = 5;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[2].binding = 6;
        bindings[2].descriptorCount = 1;
        bindings[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[2].pImmutableSamplers = nullptr;
        bindings[2].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[3].binding = 7;
        bindings[3].descriptorCount = 1;
        bindings[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
        bindings[3].pImmutableSamplers = nullptr;
        bindings[3].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    {
        bindings[4].binding = 0;
        bindings[4].descriptorCount = 1;
        bindings[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[4].pImmutableSamplers = nullptr;
        bindings[4].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[5].binding = 1;
        bindings[5].descriptorCount = 1;
        bindings[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[5].pImmutableSamplers = nullptr;
        bindings[5].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[6].binding = 2;
        bindings[6].descriptorCount = 1;
        bindings[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[6].pImmutableSamplers = nullptr;
        bindings[6].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 7;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_TTTTUUU, bindings, 7);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateWaterTrapezoidStripDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Texture* texture_tex1, VK::Texture* texture_tex2, VK::Texture* texture_tex3, VK::Texture* texture_tex4, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix, VK::Buffer ubo_UVT2) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_TTTTUUU, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].subIndex, &pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[7] = {};

    VkDescriptorImageInfo imageInfo_tex1 = {};
    imageInfo_tex1.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex1.imageView = texture_tex1->imageView;
    imageInfo_tex1.sampler = texture_tex1->sampler;
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 4;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pImageInfo = &imageInfo_tex1;
    VkDescriptorImageInfo imageInfo_tex2 = {};
    imageInfo_tex2.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex2.imageView = texture_tex2->imageView;
    imageInfo_tex2.sampler = texture_tex2->sampler;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 5;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pImageInfo = &imageInfo_tex2;
    VkDescriptorImageInfo imageInfo_tex3 = {};
    imageInfo_tex3.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex3.imageView = texture_tex3->imageView;
    imageInfo_tex3.sampler = texture_tex3->sampler;
    
    descriptorWrites[2].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[2].dstSet = descriptorSet;
    descriptorWrites[2].dstBinding = 6;
    descriptorWrites[2].dstArrayElement = 0;
    descriptorWrites[2].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[2].descriptorCount = 1;
    descriptorWrites[2].pImageInfo = &imageInfo_tex3;
    VkDescriptorImageInfo imageInfo_tex4 = {};
    imageInfo_tex4.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo_tex4.imageView = texture_tex4->imageView;
    imageInfo_tex4.sampler = texture_tex4->sampler;
    
    descriptorWrites[3].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[3].dstSet = descriptorSet;
    descriptorWrites[3].dstBinding = 7;
    descriptorWrites[3].dstArrayElement = 0;
    descriptorWrites[3].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[3].descriptorCount = 1;
    descriptorWrites[3].pImageInfo = &imageInfo_tex4;
    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[4].dstSet = descriptorSet;
    descriptorWrites[4].dstBinding = 0;
    descriptorWrites[4].dstArrayElement = 0;
    descriptorWrites[4].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[4].descriptorCount = 1;
    descriptorWrites[4].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[5].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[5].dstSet = descriptorSet;
    descriptorWrites[5].dstBinding = 1;
    descriptorWrites[5].dstArrayElement = 0;
    descriptorWrites[5].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[5].descriptorCount = 1;
    descriptorWrites[5].pBufferInfo = &bufferInfo_ViewMatrix;
    VkDescriptorBufferInfo bufferInfo_UVT2 = {};
    bufferInfo_UVT2.buffer = ubo_UVT2.buffer;
    bufferInfo_UVT2.offset = 0;
    bufferInfo_UVT2.range = sizeof(UVT2);
    
    descriptorWrites[6].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[6].dstSet = descriptorSet;
    descriptorWrites[6].dstBinding = 2;
    descriptorWrites[6].dstArrayElement = 0;
    descriptorWrites[6].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[6].descriptorCount = 1;
    descriptorWrites[6].pBufferInfo = &bufferInfo_UVT2;
    vkUpdateDescriptorSets(target->device, 7, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateVolumeShadowPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_ProjShadow_vert, sizeof(WWVK_ProjShadow_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_DummyFrag_frag, sizeof(WWVK_DummyFrag_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 3;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[1] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 1;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[13] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BIAS, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_WRITE_MASK, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_FALSE;
    colorBlendAttachment.colorWriteMask = (VkColorComponentFlagBits)0;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    pipelineInfo.pDepthStencilState = &depthStencil;
    depthStencil.stencilTestEnable = VK_TRUE;
    depthStencil.front.compareMask = 0xffffffff;
    depthStencil.front.writeMask = 0xffffffff;
    depthStencil.front.reference = 0x80808080;
    depthStencil.front.compareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    depthStencil.front.failOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.depthFailOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.passOp = VK_STENCIL_OP_REPLACE;
    depthStencil.back = depthStencil.front;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateVolumeShadowDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateVolumeShadowDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].subIndex, &pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateVolumeStencilShadowPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzd_vert, sizeof(WWVK_fvf_xyzd_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_d_frag, sizeof(WWVK_fvf_d_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 4;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_NONE;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_DST_COLOR;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_DST_COLOR;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_TRUE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_ALWAYS;
    pipelineInfo.pDepthStencilState = &depthStencil;
    depthStencil.stencilTestEnable = VK_TRUE;
    depthStencil.front.compareMask = 0xffffffff;
    depthStencil.front.writeMask = 0xffffffff;
    depthStencil.front.reference = 1;
    depthStencil.front.compareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    depthStencil.front.failOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.depthFailOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.passOp = VK_STENCIL_OP_KEEP;
    depthStencil.back = depthStencil.front;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateVolumeStencilShadowDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateVolumeStencilShadowDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].subIndex, &pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateProjShadowPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_ProjShadow_vert, sizeof(WWVK_ProjShadow_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_DummyFrag_frag, sizeof(WWVK_DummyFrag_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 3;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[1] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 1;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    inputAssembly.primitiveRestartEnable = VK_FALSE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[3] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_DST_COLOR;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;
    depthStencil.stencilTestEnable = VK_TRUE;
    depthStencil.front.compareMask = 0xffffffff;
    depthStencil.front.writeMask = 0xffffffff;
    depthStencil.front.reference = 1;
    depthStencil.front.compareOp = VK_COMPARE_OP_ALWAYS;
    depthStencil.front.failOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.depthFailOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.passOp = VK_STENCIL_OP_INCREMENT_AND_CLAMP;
    depthStencil.back = depthStencil.front;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateProjShadowDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateProjShadowDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_ProjShadow].subIndex, &pipeline.pipelines[PIPELINE_WWVK_ProjShadow].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateStencilPlayerColorPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzd_vert, sizeof(WWVK_fvf_xyzd_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_d_frag, sizeof(WWVK_fvf_d_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 4;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[7] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;
    depthStencil.stencilTestEnable = VK_TRUE;
    depthStencil.front.compareMask = 0xffffffff;
    depthStencil.front.writeMask = 0xffffffff;
    depthStencil.front.reference = 1;
    depthStencil.front.compareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    depthStencil.front.failOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.depthFailOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.passOp = VK_STENCIL_OP_REPLACE;
    depthStencil.back = depthStencil.front;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateStencilPlayerColorDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateStencilPlayerColorDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].subIndex, &pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_CreateStencilPlayerColorClearPipeline(VkRenderTarget* target, VKPipelineData& pipeline) {
    VkShaderModule vertShaderModule = createShaderModule(target->device, WWVK_fvf_xyzd_vert, sizeof(WWVK_fvf_xyzd_vert));    VkShaderModule fragShaderModule = createShaderModule(target->device, WWVK_fvf_d_frag, sizeof(WWVK_fvf_d_frag));

    VkPipelineShaderStageCreateInfo vertShaderStageInfo = {};
    vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    vertShaderStageInfo.module = vertShaderModule;
    vertShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo fragShaderStageInfo = {};
    fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
    fragShaderStageInfo.module = fragShaderModule;
    fragShaderStageInfo.pName = "main";

    VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo = {};
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    VkVertexInputBindingDescription bindingDescription[1] = {};
    {
        bindingDescription[0].binding = 0;
        bindingDescription[0].stride = sizeof(float) * 4;
        bindingDescription[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX;
    }
    VkVertexInputAttributeDescription attributeDescriptions[2] = {};
    {
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 1;
        attributeDescriptions[0].format = VK_FORMAT_R32_UINT;
        attributeDescriptions[0].offset = sizeof(float) * 3;
    }
    {
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 0;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = sizeof(float) * 0;
    }
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.vertexAttributeDescriptionCount = 2;

    vertexInputInfo.pVertexBindingDescriptions = bindingDescription;
    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions;

    VkPipelineInputAssemblyStateCreateInfo inputAssembly = {};
    inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    inputAssembly.primitiveRestartEnable = VK_TRUE;


    VkPipelineViewportStateCreateInfo viewportState = {};
    viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    viewportState.viewportCount = 1;
    viewportState.pViewports = nullptr;
    viewportState.scissorCount = 1;
    viewportState.pScissors = nullptr;

    VkDynamicState dynamicState[6] = { VK_DYNAMIC_STATE_VIEWPORT , VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK, VK_DYNAMIC_STATE_STENCIL_OP, VK_DYNAMIC_STATE_STENCIL_REFERENCE, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE };
    VkPipelineDynamicStateCreateInfo dynamicStateCreateInfo = {};
    dynamicStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicStateCreateInfo.dynamicStateCount = sizeof(dynamicState) / sizeof(dynamicState[0]);
    dynamicStateCreateInfo.pDynamicStates = dynamicState;

    VkPipelineMultisampleStateCreateInfo multisampling = {};
    multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    multisampling.sampleShadingEnable = VK_FALSE;
    multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

    VkPipelineRasterizationStateCreateInfo rasterizer = {};
    rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = VK_FALSE;
    rasterizer.rasterizerDiscardEnable = VK_FALSE;
    rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
    VkPipelineColorBlendAttachmentState colorBlendAttachment = {};
    colorBlendAttachment.blendEnable = VK_TRUE;
    colorBlendAttachment.colorWriteMask = (VkColorComponentFlagBits)0;
    colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;
    colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;
    colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;

    VkPipelineColorBlendStateCreateInfo colorBlending = {};
    colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    colorBlending.logicOpEnable = VK_FALSE;
    colorBlending.logicOp = VK_LOGIC_OP_COPY;
    colorBlending.attachmentCount = 1;
    colorBlending.pAttachments = &colorBlendAttachment;


    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {};
    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    pipelineLayoutInfo.setLayoutCount = 1;
    pipelineLayoutInfo.pSetLayouts = &pipeline.descriptorSetLayout;
    VkPushConstantRange pushConstantRange;
    pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    pushConstantRange.size = sizeof(WorldMatrix);
    pushConstantRange.offset = 0;

    // Push constant ranges are part of the pipeline layout
    pipelineLayoutInfo.pushConstantRangeCount = 1;
    pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;
    if (vkCreatePipelineLayout(target->device, &pipelineLayoutInfo, nullptr, &pipeline.pipelineLayout) != VK_SUCCESS) {
        throw std::runtime_error("failed to create pipeline layout!");
    }

    VkGraphicsPipelineCreateInfo pipelineInfo = {};
    VkPipelineDepthStencilStateCreateInfo depthStencil{};
    depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depthStencil.depthTestEnable = VK_FALSE;
    depthStencil.depthWriteEnable = VK_FALSE;
    depthStencil.depthBoundsTestEnable = VK_FALSE;
    depthStencil.minDepthBounds = 0.0f; // Optional
    depthStencil.maxDepthBounds = 1.0f; // Optional
    depthStencil.depthCompareOp = VK_COMPARE_OP_NEVER;
    pipelineInfo.pDepthStencilState = &depthStencil;
    depthStencil.stencilTestEnable = VK_TRUE;
    depthStencil.front.compareMask = 0xffffffff;
    depthStencil.front.writeMask = 0xffffffff;
    depthStencil.front.reference = 1;
    depthStencil.front.compareOp = VK_COMPARE_OP_LESS_OR_EQUAL;
    depthStencil.front.failOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.depthFailOp = VK_STENCIL_OP_KEEP;
    depthStencil.front.passOp = VK_STENCIL_OP_REPLACE;
    depthStencil.back = depthStencil.front;

    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipelineInfo.stageCount = 2;
    pipelineInfo.pStages = shaderStages;
    pipelineInfo.pVertexInputState = &vertexInputInfo;
    pipelineInfo.pInputAssemblyState = &inputAssembly;
    pipelineInfo.pViewportState = &viewportState;
    pipelineInfo.pDynamicState = &dynamicStateCreateInfo;
    pipelineInfo.pRasterizationState = &rasterizer;
    pipelineInfo.pMultisampleState = &multisampling;
    pipelineInfo.pColorBlendState = &colorBlending;
    pipelineInfo.layout = pipeline.pipelineLayout;
    pipelineInfo.renderPass = target->renderPass;
    pipelineInfo.subpass = 0;
    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

    if (vkCreateGraphicsPipelines(target->device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline.graphicsPipeline) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics pipeline!");
    }

    vkDestroyShaderModule(target->device, fragShaderModule, nullptr);
    vkDestroyShaderModule(target->device, vertShaderModule, nullptr);
}


void WWVK_CreateStencilPlayerColorClearDescriptorSetLayout(VkRenderTarget * target, VKPipelineData& pipeline) {
    VkDescriptorSetLayoutBinding bindings[2] = {};
    {
        bindings[0].binding = 0;
        bindings[0].descriptorCount = 1;
        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[0].pImmutableSamplers = nullptr;
        bindings[0].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }
    {
        bindings[1].binding = 1;
        bindings[1].descriptorCount = 1;
        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
        bindings[1].pImmutableSamplers = nullptr;
        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
    }

    VkDescriptorSetLayoutCreateInfo layoutInfo = {};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;

    pipeline.subIndex = target->getDescSetSubIndex(VkDS_UU, bindings, 2);
    if (vkCreateDescriptorSetLayout(target->device, &layoutInfo, nullptr, &pipeline.descriptorSetLayout) != VK_SUCCESS) {}
}
void WWVK_UpdateStencilPlayerColorClearDescriptorSets(VkRenderTarget * target, WWVK_Pipeline_Collection& pipeline, std::vector<VkDescriptorSet>& output, VK::Buffer ubo_Projection, VK::Buffer ubo_ViewMatrix) {
    VkDescriptorSet descriptorSet = target->getDescSet(VkDS_UU, pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].subIndex, &pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].descriptorSetLayout);
    VkWriteDescriptorSet descriptorWrites[2] = {};

    VkDescriptorBufferInfo bufferInfo_Projection = {};
    bufferInfo_Projection.buffer = ubo_Projection.buffer;
    bufferInfo_Projection.offset = 0;
    bufferInfo_Projection.range = sizeof(Projection);
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo_Projection;
    VkDescriptorBufferInfo bufferInfo_ViewMatrix = {};
    bufferInfo_ViewMatrix.buffer = ubo_ViewMatrix.buffer;
    bufferInfo_ViewMatrix.offset = 0;
    bufferInfo_ViewMatrix.range = sizeof(ViewMatrix);
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &bufferInfo_ViewMatrix;
    vkUpdateDescriptorSets(target->device, 2, descriptorWrites, 0, nullptr);
    output.clear();
    output.push_back(descriptorSet);
}
void WWVK_PopulatePipeline(VkRenderTarget* target, WWVK_Pipeline_Collection& col)
{
    WWVK_CreateFVF_DDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_D]);
    WWVK_CreateFVF_DPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_D]);
    WWVK_CreateFVF_DUVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV]);
    WWVK_CreateFVF_DUVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV]);
    WWVK_CreateFVF_DUV_DropUVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV]);
    WWVK_CreateFVF_DUV_DropUVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV]);
    WWVK_CreateFVF_DUV_NoDiffuseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse]);
    WWVK_CreateFVF_DUV_NoDiffusePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse]);
    WWVK_CreateFVF_DUV_GrayscaleDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale]);
    WWVK_CreateFVF_DUV_GrayscalePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale]);
    WWVK_CreateFVF_DUV_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_Strip]);
    WWVK_CreateFVF_DUV_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_Strip]);
    WWVK_CreateFVF_DUV_CAMUVT_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip]);
    WWVK_CreateFVF_DUV_CAMUVT_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip]);
    WWVK_CreateFVF_DUV_DepthBias_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip]);
    WWVK_CreateFVF_DUV_DepthBias_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip]);
    WWVK_CreateFVF_DUV_CAMUVT_DepthBias_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip]);
    WWVK_CreateFVF_DUV_CAMUVT_DepthBias_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip]);
    WWVK_CreateFVF_DUV2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2]);
    WWVK_CreateFVF_DUV2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2]);
    WWVK_CreateFVF_DUV2_DropUVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV]);
    WWVK_CreateFVF_DUV2_DropUVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV]);
    WWVK_CreateFVF_DUV2_DropUV_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip]);
    WWVK_CreateFVF_DUV2_DropUV_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip]);
    WWVK_CreateFVF_DUV2_DropUV_ARefDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef]);
    WWVK_CreateFVF_DUV2_DropUV_ARefPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef]);
    WWVK_CreateFVF_DUV2_TerrainPassDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass]);
    WWVK_CreateFVF_DUV2_TerrainPassPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass]);
    WWVK_CreateFVF_DUV2_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip]);
    WWVK_CreateFVF_DUV2_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip]);
    WWVK_CreateFVF_NUVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV]);
    WWVK_CreateFVF_NUVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV]);
    WWVK_CreateFVF_NUV_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_Strip]);
    WWVK_CreateFVF_NUV_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_Strip]);
    WWVK_CreateFVF_NUV_ARefDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_ARef]);
    WWVK_CreateFVF_NUV_ARefPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_ARef]);
    WWVK_CreateFVF_NUV_NoDiffuseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse]);
    WWVK_CreateFVF_NUV_NoDiffusePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse]);
    WWVK_CreateFVF_NUV_NOL_NoDiffuseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse]);
    WWVK_CreateFVF_NUV_NOL_NoDiffusePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse]);
    WWVK_CreateFVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse]);
    WWVK_CreateFVF_NUV_CAMUVT_DROPUV_NOL_NoDiffusePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse]);
    WWVK_CreateFVF_NUV_NoTexDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex]);
    WWVK_CreateFVF_NUV_NoTexPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex]);
    WWVK_CreateFVF_NUV_UVTDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_UVT]);
    WWVK_CreateFVF_NUV_UVTPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_UVT]);
    WWVK_CreateFVF_NUV_DROPUV_REFLUVTDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT]);
    WWVK_CreateFVF_NUV_DROPUV_REFLUVTPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT]);
    WWVK_CreateFVF_NUV_DROPUV_REFLUVT_ARefDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef]);
    WWVK_CreateFVF_NUV_DROPUV_REFLUVT_ARefPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef]);
    WWVK_CreateFVF_NUV_ARef_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip]);
    WWVK_CreateFVF_NUV_ARef_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip]);
    WWVK_CreateFVF_NUV_2TexDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex]);
    WWVK_CreateFVF_NUV_2TexPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex]);
    WWVK_CreateFVF_NUV_2Tex_NoDiffuseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse]);
    WWVK_CreateFVF_NUV_2Tex_NoDiffusePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse]);
    WWVK_CreateFVF_NUV_UVT_UVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV]);
    WWVK_CreateFVF_NUV_UVT_UVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV]);
    WWVK_CreateFVF_NUV_REFLUVT_UVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV]);
    WWVK_CreateFVF_NUV_REFLUVT_UVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV]);
    WWVK_CreateFVF_NUV_UVT12DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12]);
    WWVK_CreateFVF_NUV_UVT12Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12]);
    WWVK_CreateFVF_NUV_2Tex_ARefDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef]);
    WWVK_CreateFVF_NUV_2Tex_ARefPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef]);
    WWVK_CreateFVF_NDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_N]);
    WWVK_CreateFVF_NPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_N]);
    WWVK_CreateFVF_N_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_N_Strip]);
    WWVK_CreateFVF_N_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_N_Strip]);
    WWVK_CreateFVF_N_NOLDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_N_NOL]);
    WWVK_CreateFVF_N_NOLPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_N_NOL]);
    WWVK_CreateFVF_N_NOL_CAMUVTDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT]);
    WWVK_CreateFVF_N_NOL_CAMUVTPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT]);
    WWVK_CreateFVF_NDUVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV]);
    WWVK_CreateFVF_NDUVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV]);
    WWVK_CreateFVF_NDUV_NOLDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL]);
    WWVK_CreateFVF_NDUV_NOLPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL]);
    WWVK_CreateFVF_NDUV_AREFDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF]);
    WWVK_CreateFVF_NDUV_AREFPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF]);
    WWVK_CreateFVF_NDUV_AREF_StripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip]);
    WWVK_CreateFVF_NDUV_AREF_StripPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip]);
    WWVK_CreateFVF_NDUV_REFLUVT_DROPUVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV]);
    WWVK_CreateFVF_NDUV_REFLUVT_DROPUVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV]);
    WWVK_CreateFVF_NDUV_CAMUVT_NOLDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL]);
    WWVK_CreateFVF_NDUV_CAMUVT_NOLPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL]);
    WWVK_CreateFVF_NDUV_CAMUVT_NOL_AREFDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF]);
    WWVK_CreateFVF_NDUV_CAMUVT_NOL_AREFPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF]);
    WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOLDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL]);
    WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOLPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL]);
    WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffuseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse]);
    WWVK_CreateFVF_NDUV_DropUV_CAMUVT_NoDiffusePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse]);
    WWVK_CreateFVF_NDUV_NoDiffuseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse]);
    WWVK_CreateFVF_NDUV_NoDiffusePipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse]);
    WWVK_CreateFVF_NDUV_UVT_NOLDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL]);
    WWVK_CreateFVF_NDUV_UVT_NOLPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL]);
    WWVK_CreateFVF_NDUV_UVT2_UVT_PLUS_UVTRGBDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB]);
    WWVK_CreateFVF_NDUV_UVT2_UVT_PLUS_UVTRGBPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB]);
    WWVK_CreateFVF_NDUV_UV_PLUS_UVRGBDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB]);
    WWVK_CreateFVF_NDUV_UV_PLUS_UVRGBPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB]);
    WWVK_CreateFVF_NDUV2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2]);
    WWVK_CreateFVF_NDUV2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2]);
    WWVK_CreateFVF_NDUV2_UVT2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2]);
    WWVK_CreateFVF_NDUV2_UVT2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2]);
    WWVK_CreateFVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGBDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB]);
    WWVK_CreateFVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGBPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB]);
    WWVK_CreateFVF_NDUV2_DROPUV_UV_PLUS_UVRGBDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB]);
    WWVK_CreateFVF_NDUV2_DROPUV_UV_PLUS_UVRGBPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB]);
    WWVK_CreateFVF_NDUV2_UVT2_NoAlpha2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2]);
    WWVK_CreateFVF_NDUV2_UVT2_NoAlpha2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2]);
    WWVK_CreateFVF_NDUV2_NoAlpha2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2]);
    WWVK_CreateFVF_NDUV2_NoAlpha2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2]);
    WWVK_CreateFVF_NDUV2_DropUVDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV]);
    WWVK_CreateFVF_NDUV2_DropUVPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV]);
    WWVK_CreateFVF_NDUV2_DropUV_RGB1_A2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2]);
    WWVK_CreateFVF_NDUV2_DropUV_RGB1_A2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2]);
    WWVK_CreateFVF_NDUV2_UVT1_UV1DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1]);
    WWVK_CreateFVF_NDUV2_UVT1_UV1Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1]);
    WWVK_CreateFVF_NDUV2_DropUV_ARefDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef]);
    WWVK_CreateFVF_NDUV2_DropUV_ARefPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef]);
    WWVK_CreateFVF_NDUV2_DropTex_ARefDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef]);
    WWVK_CreateFVF_NDUV2_DropTex_ARefPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef]);
    WWVK_CreateFVF_NDUV2_DropTex_UV2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2]);
    WWVK_CreateFVF_NDUV2_DropTex_UV2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2]);
    WWVK_CreateFVF_NDUV2_DropTexDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex]);
    WWVK_CreateFVF_NDUV2_DropTexPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex]);
    WWVK_CreateFVF_NDUV2_UVT1_DropTexDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex]);
    WWVK_CreateFVF_NDUV2_UVT1_DropTexPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex]);
    WWVK_CreateFVF_NDUV2_NOLDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL]);
    WWVK_CreateFVF_NDUV2_NOLPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL]);
    WWVK_CreateFVF_NDUV2_NOL_OnlyTex1DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1]);
    WWVK_CreateFVF_NDUV2_NOL_OnlyTex1Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1]);
    WWVK_CreateFVF_NDUV2_OnlyTex2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2]);
    WWVK_CreateFVF_NDUV2_OnlyTex2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2]);
    WWVK_CreateFVF_NDUV2_CAMUVT_NOL_OnlyTex1DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1]);
    WWVK_CreateFVF_NDUV2_CAMUVT_NOL_OnlyTex1Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1]);
    WWVK_CreateFVF_NDUV2_NOL_DROPTEXDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX]);
    WWVK_CreateFVF_NDUV2_NOL_DROPTEXPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX]);
    WWVK_CreateFVF_NDUV2_NOL_DROPTEX2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2]);
    WWVK_CreateFVF_NDUV2_NOL_DROPTEX2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2]);
    WWVK_CreateFVF_NDUV2_NOL_DROPTEX_NoTexAlphaDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha]);
    WWVK_CreateFVF_NDUV2_NOL_DROPTEX_NoTexAlphaPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha]);
    WWVK_CreateFVF_NDUV2_DROPTEX2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2]);
    WWVK_CreateFVF_NDUV2_DROPTEX2Pipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2]);
    WWVK_CreateFVF_NDUV2_NOL_AREFDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF]);
    WWVK_CreateFVF_NDUV2_NOL_AREFPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF]);
    WWVK_CreateFVF_NDUV2_NOL_AREF_DROPTEXDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX]);
    WWVK_CreateFVF_NDUV2_NOL_AREF_DROPTEXPipeline(target, col.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX]);
    WWVK_CreateHaloDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Halo]);
    WWVK_CreateHaloPipeline(target, col.pipelines[PIPELINE_WWVK_Halo]);
    WWVK_CreateDazzleDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Dazzle]);
    WWVK_CreateDazzlePipeline(target, col.pipelines[PIPELINE_WWVK_Dazzle]);
    WWVK_CreateSnowDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Snow]);
    WWVK_CreateSnowPipeline(target, col.pipelines[PIPELINE_WWVK_Snow]);
    WWVK_CreateFTerrainDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FTerrain]);
    WWVK_CreateFTerrainPipeline(target, col.pipelines[PIPELINE_WWVK_FTerrain]);
    WWVK_CreateFTerrainNoiseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FTerrainNoise]);
    WWVK_CreateFTerrainNoisePipeline(target, col.pipelines[PIPELINE_WWVK_FTerrainNoise]);
    WWVK_CreateFTerrainNoise2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_FTerrainNoise2]);
    WWVK_CreateFTerrainNoise2Pipeline(target, col.pipelines[PIPELINE_WWVK_FTerrainNoise2]);
    WWVK_CreateRoadDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Road]);
    WWVK_CreateRoadPipeline(target, col.pipelines[PIPELINE_WWVK_Road]);
    WWVK_CreateRoadNoiseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_RoadNoise]);
    WWVK_CreateRoadNoisePipeline(target, col.pipelines[PIPELINE_WWVK_RoadNoise]);
    WWVK_CreateRoadNoise12DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_RoadNoise12]);
    WWVK_CreateRoadNoise12Pipeline(target, col.pipelines[PIPELINE_WWVK_RoadNoise12]);
    WWVK_CreateMonochromeDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Monochrome]);
    WWVK_CreateMonochromePipeline(target, col.pipelines[PIPELINE_WWVK_Monochrome]);
    WWVK_CreateMotionBlurDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_MotionBlur]);
    WWVK_CreateMotionBlurPipeline(target, col.pipelines[PIPELINE_WWVK_MotionBlur]);
    WWVK_CreateBumpDiffDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_BumpDiff]);
    WWVK_CreateBumpDiffPipeline(target, col.pipelines[PIPELINE_WWVK_BumpDiff]);
    WWVK_CreateBumpSpecDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_BumpSpec]);
    WWVK_CreateBumpSpecPipeline(target, col.pipelines[PIPELINE_WWVK_BumpSpec]);
    WWVK_CreateSSBumpDiffDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_SSBumpDiff]);
    WWVK_CreateSSBumpDiffPipeline(target, col.pipelines[PIPELINE_WWVK_SSBumpDiff]);
    WWVK_CreateSSBumpSpecDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_SSBumpSpec]);
    WWVK_CreateSSBumpSpecPipeline(target, col.pipelines[PIPELINE_WWVK_SSBumpSpec]);
    WWVK_CreateTerrainDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Terrain]);
    WWVK_CreateTerrainPipeline(target, col.pipelines[PIPELINE_WWVK_Terrain]);
    WWVK_CreateTerrainNoiseDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_TerrainNoise]);
    WWVK_CreateTerrainNoisePipeline(target, col.pipelines[PIPELINE_WWVK_TerrainNoise]);
    WWVK_CreateTerrainNoise2DescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_TerrainNoise2]);
    WWVK_CreateTerrainNoise2Pipeline(target, col.pipelines[PIPELINE_WWVK_TerrainNoise2]);
    WWVK_CreateTreesDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Trees]);
    WWVK_CreateTreesPipeline(target, col.pipelines[PIPELINE_WWVK_Trees]);
    WWVK_CreateWaveDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_Wave]);
    WWVK_CreateWavePipeline(target, col.pipelines[PIPELINE_WWVK_Wave]);
    WWVK_CreateRiverWaterDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_RiverWater]);
    WWVK_CreateRiverWaterPipeline(target, col.pipelines[PIPELINE_WWVK_RiverWater]);
    WWVK_CreateRiverWaterAddDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_RiverWaterAdd]);
    WWVK_CreateRiverWaterAddPipeline(target, col.pipelines[PIPELINE_WWVK_RiverWaterAdd]);
    WWVK_CreateRiverWaterShroudDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_RiverWaterShroud]);
    WWVK_CreateRiverWaterShroudPipeline(target, col.pipelines[PIPELINE_WWVK_RiverWaterShroud]);
    WWVK_CreateWaterTrapezoidDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoid]);
    WWVK_CreateWaterTrapezoidPipeline(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoid]);
    WWVK_CreateWaterTrapezoid_DstAlphaDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha]);
    WWVK_CreateWaterTrapezoid_DstAlphaPipeline(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha]);
    WWVK_CreateWaterTrapezoid_DstAlphaInvDestDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest]);
    WWVK_CreateWaterTrapezoid_DstAlphaInvDestPipeline(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest]);
    WWVK_CreateWaterTrapezoidStripDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip]);
    WWVK_CreateWaterTrapezoidStripPipeline(target, col.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip]);
    WWVK_CreateVolumeShadowDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_VolumeShadow]);
    WWVK_CreateVolumeShadowPipeline(target, col.pipelines[PIPELINE_WWVK_VolumeShadow]);
    WWVK_CreateVolumeStencilShadowDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_VolumeStencilShadow]);
    WWVK_CreateVolumeStencilShadowPipeline(target, col.pipelines[PIPELINE_WWVK_VolumeStencilShadow]);
    WWVK_CreateProjShadowDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_ProjShadow]);
    WWVK_CreateProjShadowPipeline(target, col.pipelines[PIPELINE_WWVK_ProjShadow]);
    WWVK_CreateStencilPlayerColorDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_StencilPlayerColor]);
    WWVK_CreateStencilPlayerColorPipeline(target, col.pipelines[PIPELINE_WWVK_StencilPlayerColor]);
    WWVK_CreateStencilPlayerColorClearDescriptorSetLayout(target, col.pipelines[PIPELINE_WWVK_StencilPlayerColorClear]);
    WWVK_CreateStencilPlayerColorClearPipeline(target, col.pipelines[PIPELINE_WWVK_StencilPlayerColorClear]);
}


void WWVK_DrawFVF_D_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_D].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_D].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_D].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_D(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_D].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_D].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_D].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_DropUV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV_DropUV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DropUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_NoDiffuse_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV_NoDiffuse(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_Grayscale_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV_Grayscale(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Grayscale].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_CAMUVT_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV_CAMUVT_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_DepthBias_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV_DepthBias_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_DepthBias_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV_CAMUVT_DepthBias_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV_CAMUVT_DepthBias_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV_CAMUVT_DepthBias_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV2_DropUV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV2_DropUV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV2_DropUV_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV2_DropUV_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV2_DropUV_ARef_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV2_DropUV_ARef(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_DropUV_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV2_TerrainPass_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV2_TerrainPass(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_TerrainPass].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_DUV2_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_DUV2_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_DUV2_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_ARef_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_ARef(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_NoDiffuse_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_NoDiffuse(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_NOL_NoDiffuse_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_NOL_NoDiffuse(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NOL_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_CAMUVT_DROPUV_NOL_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_NoTex_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_NoTex(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_NoTex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_UVT_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_UVT(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_DROPUV_REFLUVT_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_DROPUV_REFLUVT(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_DROPUV_REFLUVT_ARef_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_DROPUV_REFLUVT_ARef(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_DROPUV_REFLUVT_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_ARef_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_ARef_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_ARef_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_2Tex_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_2Tex(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_2Tex_NoDiffuse_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_2Tex_NoDiffuse(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_UVT_UV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_UVT_UV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT_UV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_REFLUVT_UV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_REFLUVT_UV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_REFLUVT_UV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_UVT12_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_UVT12(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_UVT12].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NUV_2Tex_ARef_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NUV_2Tex_ARef(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NUV_2Tex_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_N_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_N(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_N_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_N_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_N_NOL_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_N_NOL(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_N_NOL_CAMUVT_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_N_NOL_CAMUVT(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_N_NOL_CAMUVT].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_NOL_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_NOL(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_AREF_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_AREF(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_AREF_Strip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_AREF_Strip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_AREF_Strip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_REFLUVT_DROPUV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_REFLUVT_DROPUV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_REFLUVT_DROPUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_CAMUVT_NOL_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_CAMUVT_NOL(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_CAMUVT_NOL_AREF_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_CAMUVT_NOL_AREF(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_CAMUVT_NOL_AREF].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_DropUV_CAMUVT_NoDiffuse_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_DropUV_CAMUVT_NoDiffuse(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_DropUV_CAMUVT_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_NoDiffuse_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_NoDiffuse(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_NoDiffuse].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_UVT_NOL_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUvt* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUvt),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_UVT_NOL(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUvt* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUvt),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_UVT2_UVT_PLUS_UVTRGB_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_UVT2_UVT_PLUS_UVTRGB(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV_UV_PLUS_UVRGB_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV_UV_PLUS_UVRGB(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV_UV_PLUS_UVRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_UVT2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_UVT2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UVT2_UVT_PLUS_UVTRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DROPUV_UV_PLUS_UVRGB_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DROPUV_UV_PLUS_UVRGB(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPUV_UV_PLUS_UVRGB].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_UVT2_NoAlpha2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_UVT2_NoAlpha2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT2_NoAlpha2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NoAlpha2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NoAlpha2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NoAlpha2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DropUV_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DropUV(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DropUV_RGB1_A2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DropUV_RGB1_A2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_RGB1_A2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_UVT1_UV1_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_UVT1_UV1(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_UV1].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DropUV_ARef_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DropUV_ARef(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropUV_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DropTex_ARef_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DropTex_ARef(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_ARef].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DropTex_UV2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DropTex_UV2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex_UV2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DropTex_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DropTex(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DropTex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_UVT1_DropTex_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_UVT1_DropTex(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_UVT1_DropTex].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NOL_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NOL(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NOL_OnlyTex1_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NOL_OnlyTex1(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_OnlyTex1].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_OnlyTex2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_OnlyTex2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_OnlyTex2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_CAMUVT_NOL_OnlyTex1_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_CAMUVT_NOL_OnlyTex1(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_CAMUVT_NOL_OnlyTex1].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NOL_DROPTEX_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NOL_DROPTEX(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NOL_DROPTEX2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NOL_DROPTEX2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NOL_DROPTEX_NoTexAlpha_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NOL_DROPTEX_NoTexAlpha(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_DROPTEX_NoTexAlpha].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_DROPTEX2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_DROPTEX2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_DROPTEX2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NOL_AREF_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NOL_AREF(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFVF_NDUV2_NOL_AREF_DROPTEX_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFVF_NDUV2_NOL_AREF_DROPTEX(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix_AlphaRef* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_AlphaRef, frag),
        sizeof(AlphaRef),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FVF_NDUV2_NOL_AREF_DROPTEX].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawHalo_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Halo].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Halo].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Halo].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawHalo(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Halo].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Halo].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Halo].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawDazzle_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Dazzle].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Dazzle].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Dazzle].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawDazzle(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Dazzle].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Dazzle].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Dazzle].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawSnow_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Snow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Snow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Snow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawSnow(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Snow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Snow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Snow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFTerrain_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FTerrain].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FTerrain].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FTerrain].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFTerrain(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FTerrain].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FTerrain].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FTerrain].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFTerrainNoise_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFTerrainNoise(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawFTerrainNoise2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawFTerrainNoise2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_FTerrainNoise2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawRoad_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Road].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Road].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Road].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawRoad(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Road].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Road].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Road].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawRoadNoise_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RoadNoise].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawRoadNoise(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrixUVT* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RoadNoise].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrixUVT),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawRoadNoise12_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawRoadNoise12(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RoadNoise12].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawMonochrome_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix_Monochrome* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Monochrome].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Monochrome].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Monochrome].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_Monochrome, frag),
        sizeof(Monochrome),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Monochrome].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawMonochrome(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix_Monochrome* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Monochrome].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Monochrome].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Monochrome].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_Monochrome, frag),
        sizeof(Monochrome),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Monochrome].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawMotionBlur_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix_BumpEnv* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_MotionBlur].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_MotionBlur].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_MotionBlur].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_BumpEnv, frag),
        sizeof(BumpEnv),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_MotionBlur].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawMotionBlur(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, WorldMatrix_BumpEnv* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_MotionBlur].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_MotionBlur].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_MotionBlur].pipelineLayout,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        offsetof(WorldMatrix_BumpEnv, frag),
        sizeof(BumpEnv),
        &push->frag);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_MotionBlur].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawBumpDiff_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_BumpDiff].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_BumpDiff].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_BumpDiff].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawBumpDiff(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_BumpDiff].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_BumpDiff].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_BumpDiff].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawBumpSpec_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_BumpSpec].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_BumpSpec].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_BumpSpec].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawBumpSpec(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_BumpSpec].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_BumpSpec].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_BumpSpec].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawSSBumpDiff_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawSSBumpDiff(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_SSBumpDiff].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawSSBumpSpec_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawSSBumpSpec(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_SSBumpSpec].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawTerrain_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Terrain].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Terrain].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Terrain].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawTerrain(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Terrain].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Terrain].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Terrain].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawTerrainNoise_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawTerrainNoise(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawTerrainNoise2_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawTerrainNoise2(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv0, VkDeviceSize offset_uv0, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv0,  };
    VkDeviceSize offsets[] = { offset_uv0,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_TerrainNoise2].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawTrees_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Trees].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Trees].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Trees].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawTrees(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Trees].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Trees].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Trees].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawWave_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv, VkDeviceSize offset_uv, Wave* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Wave].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Wave].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT|VK_SHADER_STAGE_FRAGMENT_BIT,
        0,
        sizeof(Wave),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Wave].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawWave(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv, VkDeviceSize offset_uv, Wave* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_Wave].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv,  };
    VkDeviceSize offsets[] = { offset_uv,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_Wave].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT|VK_SHADER_STAGE_FRAGMENT_BIT,
        0,
        sizeof(Wave),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_Wave].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawRiverWater_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RiverWater].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RiverWater].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RiverWater].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawRiverWater(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RiverWater].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RiverWater].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RiverWater].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawRiverWaterAdd_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawRiverWaterAdd(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterAdd].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawRiverWaterShroud_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawRiverWaterShroud(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer norm, VkDeviceSize offset_norm, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].graphicsPipeline);

    VkBuffer vertexBuffers[] = { norm,  };
    VkDeviceSize offsets[] = { offset_norm,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_RiverWaterShroud].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawWaterTrapezoid_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawWaterTrapezoid(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawWaterTrapezoid_DstAlpha_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawWaterTrapezoid_DstAlpha(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlpha].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawWaterTrapezoid_DstAlphaInvDest_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawWaterTrapezoid_DstAlphaInvDest(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoid_DstAlphaInvDest].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawWaterTrapezoidStrip_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawWaterTrapezoidStrip(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer uv1, VkDeviceSize offset_uv1, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].graphicsPipeline);

    VkBuffer vertexBuffers[] = { uv1,  };
    VkDeviceSize offsets[] = { offset_uv1,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_WaterTrapezoidStrip].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawVolumeShadow_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawVolumeShadow(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_VolumeShadow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawVolumeStencilShadow_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawVolumeStencilShadow(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_VolumeStencilShadow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawProjShadow_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_ProjShadow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_ProjShadow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_ProjShadow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawProjShadow(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer vert, VkDeviceSize offset_vert, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_ProjShadow].graphicsPipeline);

    VkBuffer vertexBuffers[] = { vert,  };
    VkDeviceSize offsets[] = { offset_vert,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_ProjShadow].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_ProjShadow].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawStencilPlayerColor_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawStencilPlayerColor(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColor].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}

void WWVK_DrawStencilPlayerColorClear_NI(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, uint32_t vertexCount, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDraw(command, vertexCount, 1, 0, 0); 
}

void WWVK_DrawStencilPlayerColorClear(WWVK_Pipeline_Collection& pipeline, VkCommandBuffer command, std::vector<VkDescriptorSet>& sets, VkBuffer indexBuffer, uint32_t indexCount, uint32_t indexOffset, VkIndexType indexType, VkBuffer diffuse, VkDeviceSize offset_diffuse, WorldMatrix* push)
{
    vkCmdBindPipeline(command, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].graphicsPipeline);

    VkBuffer vertexBuffers[] = { diffuse,  };
    VkDeviceSize offsets[] = { offset_diffuse,  };
    vkCmdPushConstants(
        command,
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].pipelineLayout,
        VK_SHADER_STAGE_VERTEX_BIT,
        0,
        sizeof(WorldMatrix),
        push);

    vkCmdBindVertexBuffers(command, 0, 1, vertexBuffers, offsets);

    vkCmdBindIndexBuffer(command, indexBuffer, 0, indexType);

    vkCmdBindDescriptorSets(command, VK_PIPELINE_BIND_POINT_GRAPHICS, 
        pipeline.pipelines[PIPELINE_WWVK_StencilPlayerColorClear].pipelineLayout, 0, static_cast<uint32_t>(sets.size()), sets.data(), 0, nullptr);

    vkCmdDrawIndexed(command, indexCount, 1, indexOffset, 0, 0);
}